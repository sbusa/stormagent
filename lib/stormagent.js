// Generated by CoffeeScript 1.4.0
(function() {
  var EventEmitter, StormAgent, StormData, StormRegistry, agent, argv, async, config, storm, stormlog, util, uuid, _ref, _ref1, _ref2,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice;

  EventEmitter = require('events').EventEmitter;

  util = require('util');

  stormlog = function(message, obj) {
    var out;
    if (message != null) {
      out = "" + this.constructor.name + ": " + message;
    }
    if (obj != null) {
      out += "\n" + util.inspect(obj);
    }
    if (out != null) {
      return util.log(out);
    }
  };

  uuid = require('node-uuid');

  StormData = (function(_super) {
    var validate;

    __extends(StormData, _super);

    validate = require('json-schema').validate;

    function StormData(id, data, schema) {
      var res, _ref;
      this.id = id;
      this.data = data;
      this.log = stormlog;
      if (schema != null) {
        res = validate(data, schema);
        if (!res.valid) {
          throw new Error("unable to validate passed in data during StormData creation! " + util.inspect(res));
        }
      }
      if ((_ref = this.id) == null) {
        this.id = uuid.v4();
      }
      if (data != null) {
        this.validity = data.validity;
      }
      this.saved = false;
    }

    return StormData;

  })(EventEmitter);

  async = require('async');

  StormRegistry = (function(_super) {

    __extends(StormRegistry, _super);

    function StormRegistry(filename) {
      var _this = this;
      this.log = stormlog;
      this.running = true;
      this.entries = [];
      if (filename) {
        this.db = require('dirty')("" + filename);
        this.db.on('load', function() {
          _this.log("loaded " + filename);
          try {
            _this.db.forEach(function(key, val) {
              _this.log("found " + key + " with:", val);
              if (val != null) {
                return _this.emit('load', key, val);
              }
            });
          } catch (err) {
            _this.log("issue during processing the db file at " + filename);
          }
          return _this.emit('ready');
        });
        this.db._writeStream.on('error', function(err) {
          return _this.log(err);
        });
      } else {
        this.emit('ready');
      }
    }

    StormRegistry.prototype.add = function(key, entry) {
      var data, _ref, _ref1;
      if (entry == null) {
        return;
      }
      if (this.get(key)) {
        this.remove(key);
      }
      if (key == null) {
        key = uuid.v4();
      }
      if ((_ref = entry.id) == null) {
        entry.id = key;
      }
      if ((_ref1 = entry.saved) == null) {
        entry.saved = false;
      }
      this.log("adding " + key + " into entries");
      if ((this.db != null) && !entry.saved) {
        data = entry;
        if (entry instanceof StormData) {
          data = entry.data;
        }
        this.db.set(key, data);
        entry.saved = true;
      }
      this.entries[key] = entry;
      this.emit('added', entry);
      return entry;
    };

    StormRegistry.prototype.get = function(key) {
      if (key == null) {
        return;
      }
      return this.entries[key];
    };

    StormRegistry.prototype.remove = function(key) {
      var entry;
      if (key == null) {
        return;
      }
      this.log("removing " + key + " from entries");
      entry = this.entries[key];
      delete this.entries[key];
      if (entry != null) {
        this.emit('removed', entry);
      }
      if ((this.db != null) && (entry != null) && entry.saved) {
        return this.db.rm(key);
      }
    };

    StormRegistry.prototype.update = function(key, entry) {
      var data;
      if (!((key != null) && (entry != null))) {
        return;
      }
      if ((this.db != null) && !entry.saved) {
        data = entry;
        if (entry instanceof StormData) {
          data = entry.data;
        }
        this.db.set(key, data);
        entry.saved = true;
      }
      this.entries[key] = entry;
      this.emit('updated', entry);
      return entry;
    };

    StormRegistry.prototype.list = function() {
      var key, _results;
      _results = [];
      for (key in this.entries) {
        _results.push(this.get(key));
      }
      return _results;
    };

    StormRegistry.prototype.checksum = function() {
      var crypto, entry, key, md5, _ref;
      crypto = require('crypto');
      md5 = crypto.createHash("md5");
      _ref = this.entries;
      for (key in _ref) {
        entry = _ref[key];
        md5.update(key);
      }
      return md5.digest("hex");
    };

    StormRegistry.prototype.expires = function(interval, validity) {
      var entry, key, _fn, _ref,
        _this = this;
      if (validity == null) {
        validity = 60 * 60;
      }
      _ref = this.entries;
      _fn = function(entry) {
        var _ref1;
        return (_ref1 = entry.validity) != null ? _ref1 : entry.validity = validity;
      };
      for (key in _ref) {
        entry = _ref[key];
        _fn(entry);
      }
      return async.whilst(function() {
        return _this.running;
      }, function(repeat) {
        var _fn1, _ref1;
        _ref1 = _this.entries;
        _fn1 = function(key, entry) {
          _this.entries[key].validity -= interval / 1000;
          if (!(_this.entries[key].validity > 1)) {
            _this.remove(key);
            return _this.emit("expired", entry);
          }
        };
        for (key in _ref1) {
          entry = _ref1[key];
          if (entry == null) {
            _this.remove(key);
            continue;
          }
          _fn1(key, entry);
        }
        return setTimeout(repeat, interval);
      }, function(err) {
        return _this.log("stormregistry stopped, validity checker stopping...");
      });
    };

    return StormRegistry;

  })(EventEmitter);

  StormAgent = (function(_super) {
    var extend, fs, path, validate;

    __extends(StormAgent, _super);

    validate = require('json-schema').validate;

    fs = require('fs');

    path = require('path');

    extend = require('util')._extend;

    function StormAgent(config) {
      var key, match, val, _ref, _ref1, _ref2,
        _this = this;
      this.log = stormlog;
      this.newdb = function(filename, callback) {};
      this.timestamp = function() {
        var d, months, pad, time;
        d = new Date();
        pad = function(n) {
          var sn;
          sn = n.toString(10);
          if (n < 10) {
            sn = '0' + sn;
          }
          return sn;
        };
        time = [pad(d.getHours()), pad(d.getMinutes()), pad(d.getSeconds())].join(':');
        months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
        return [d.getDate(), months[d.getMonth()], time].join(' ');
      };
      uuid = require('node-uuid');
      this.state = {
        id: null,
        instance: uuid.v4(),
        activated: false,
        running: false,
        env: null
      };
      if ((_ref = this.config) == null) {
        this.config = {};
      }
      if ((_ref1 = this.functions) == null) {
        this.functions = [];
      }
      this["import"](module);
      _ref2 = process.env;
      for (key in _ref2) {
        val = _ref2[key];
        match = ("" + key).match(/^npm_package_config_(.*)$/);
        if (match != null) {
          this.log("found npm package config " + match + " = " + val);
        }
      }
      if (config != null) {
        this.config = extend(this.config, config);
      }
      this.log("agent.config", this.config);
      this.log("agent.functions", this.functions);
      this.env = require('./environment');
      /*
              @log "setting up directories..."
              try
                  fs.mkdirSync("#{config.datadir}") unless fs.existsSync("#{config.datadir}")
                  fs.mkdirSync("#{config.datadir}/db")  unless fs.existsSync("#{config.datadir}/db")
                  fs.mkdirSync("#{config.datadir}/certs") unless fs.existsSync("#{config.datadir}/certs")
              catch error
                  util.log "Error in creating data dirs"
      */

      this.on('running', function(include) {
        _this.include = include;
        console.log("we are running now...");
        return _this.state.running = true;
      });
    }

    StormAgent.prototype.status = function() {
      this.state.config = extend({}, this.config);
      delete this.state.config.ca;
      delete this.state.config.cert;
      delete this.state.config.key;
      delete this.state.env.bolt.ca;
      delete this.state.env.bolt.cert;
      delete this.state.env.bolt.key;
      this.state.os = this.env.os();
      return this.state;
    };

    StormAgent.prototype.validate = function(input, schema) {
      var res;
      if (schema != null) {
        res = validate(input, schema);
        return res.valid;
      } else {
        return true;
      }
    };

    StormAgent.prototype.run = function(config, schema) {
      var logfile, res, _agent, _ref,
        _this = this;
      _agent = this;
      if (config != null) {
        if (schema != null) {
          res = validate(config, schema);
          this.log('run - validation of runtime config:', res);
          if (res.valid) {
            this.config = extend(this.config, config);
          }
        } else {
          this.config = extend(this.config, config);
        }
      }
      if (this.config.logfile != null) {
        this.log("redirecting console.log to " + this.config.logfile + "...");
        try {
          logfile = fs.createWriteStream(this.config.logfile, {
            flags: 'a'
          });
          logfile.on('open', function() {
            _this.log("starting stdout/stderr redirection...");
            process.__defineGetter__("stdout", function() {
              return logfile;
            });
            process.__defineGetter__("stderr", function() {
              return logfile;
            });
            return _this.log('running with: ', _this.config);
          });
          logfile.on('error', function(err) {
            return _this.log("unable to redirect stdout due to:", err);
          });
        } catch (err) {
          this.log("unable to redirect stdout due to:", err);
        }
      }
      return _ref = require('zappajs')(this.config.port, function() {
        var logger, morgan,
          _this = this;
        morgan = require('morgan');
        morgan.token('date', _agent.timestamp);
        logger = morgan(":date - :method :url :status :response-time ms - :remote-addr");
        this.configure(function() {
          _this.use('bodyParser', 'methodOverride', logger, require("passport").initialize(), _this.app.router, 'static');
          _this.set({
            'basepath': '/v1.0'
          });
          return _this.set({
            'agent': _agent
          });
        });
        this.configure({
          development: function() {
            return _this.use({
              errorHandler: {
                dumpExceptions: true,
                showStack: true
              }
            });
          },
          production: function() {
            return _this.use('errorHandler');
          }
        });
        return _agent.emit('running', this.include);
      }), this.app = _ref.app, _ref;
    };

    StormAgent.prototype["import"] = function(id) {
      var p, pkgconfig, plugfile, self, storm, _fn, _i, _len, _ref, _ref1,
        _this = this;
      if (id instanceof Object && (id.filename != null)) {
        self = true;
        id = p = id.filename;
        while ((p = path.dirname(p)) && p !== path.sep && !fs.existsSync("" + p + "/package.json")) {
          this.log("checking " + p + "...");
        }
        if (p !== path.sep) {
          id = p;
        }
      }
      try {
        pkgconfig = require("" + id + "/package.json").config;
        storm = pkgconfig.storm;
        this.log("import - [" + id + "] processing storm compatible module...");
        if (storm.functions != null) {
          this.log("import - [" + id + "] extending config and functions...");
          if (!this.state.running) {
            this.config = extend(this.config, pkgconfig);
          }
          delete this.config.storm;
          this.log("import - [" + id + "] available functions:", storm.functions);
          if (storm.functions != null) {
            (_ref = this.functions).push.apply(_ref, storm.functions);
          }
        }
        if (storm.plugins != null) {
          this.log("import - [" + id + "] available plugins:", storm.plugins);
          _ref1 = storm.plugins;
          _fn = function(plugfile) {
            var plugin;
            plugin = require("" + id + "/" + plugfile);
            if (!plugin) {
              return;
            }
            _this.log("import - [" + id + "] found valid plugin at " + plugfile);
            if (_this.state.running) {
              _this.include(plugin);
            }
            return _this.on('running', function(include) {
              _this.include = include;
              _this.log("loading storm-compatible plugin for: " + id + "/" + plugfile);
              try {
                return _this.include(plugin);
              } catch (err) {
                return _this.log("Unable to include the plugin " + plugin + "!! " + err);
              }
            });
          };
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            plugfile = _ref1[_i];
            _fn(plugfile);
          }
        }
      } catch (err) {
        this.log(("import - [" + id + "] is not a storm compatible module: ") + err);
      }
      try {
        if (!((self != null) && self)) {
          return require("" + id);
        }
      } catch (err) {
        return this.log(("import - [" + id + "] failed with: ") + err);
      }
    };

    StormAgent.prototype.imports = function() {
      var module, modules, _i, _len, _results;
      modules = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      _results = [];
      for (_i = 0, _len = modules.length; _i < _len; _i++) {
        module = modules[_i];
        _results.push(this["import"](module));
      }
      return _results;
    };

    StormAgent.prototype.execute = function(command, callback) {
      var exec,
        _this = this;
      if (!command) {
        return callback(new Error("no valid command for execution!"));
      }
      console.log("executing " + command + "...");
      exec = require('child_process').exec;
      return exec(command, function(error, stdout, stderr) {
        if (error) {
          return callback(error);
        } else {
          return callback();
        }
      });
    };

    StormAgent.prototype.activate = function(storm, callback) {
      var count, request, srequest,
        _this = this;
      request = require('request');
      count = 0;
      srequest = function(method, url, storm, callback) {
        if ((method != null) && method instanceof Function && (url != null) && (storm != null)) {
          return method({
            url: url,
            timeout: 2000
          }, function(err, res, body) {
            if (callback != null) {
              return callback(err, res, body);
            }
          }).auth(storm.skey, storm.token);
        }
      };
      return async.until(function() {
        return _this.state.activated;
      }, function(repeat) {
        count++;
        _this.log("attempting activation (try " + count + ")...");
        return async.waterfall([
          function(next) {
            if ((storm != null) && (storm.tracker != null) && (storm.skey != null) && (storm.token != null)) {
              return next(null, storm);
            }
            _this.log("discovering environment...");
            return _this.env.discover(function(storm) {
              if ((storm != null) && (storm.provider != null) && (storm.skey != null)) {
                _this.log("detected provider as: " + storm.provider + " with skey: " + storm.skey);
                if ((storm.tracker != null) && (storm.token != null)) {
                  _this.state.env = storm;
                  return next(null, storm);
                } else {
                  return next(new Error("unable to retrieve storm tracker and token data!"));
                }
              } else {
                return next(new Error("unable to discover environment!"));
              }
            });
          }, function(storm, next) {
            if (storm.id != null) {
              _this.state.id = storm.id;
              return next(null, storm);
            }
            _this.log("looking up agent ID from stormtracker... " + storm.tracker);
            return srequest(request, "" + storm.tracker + "/agents/serialkey/" + storm.skey, storm, function(err, res, body) {
              var agent;
              try {
                if (err) {
                  next(err);
                }
                switch (res.statusCode) {
                  case 200:
                    agent = JSON.parse(body);
                    _this.state.id = storm.id = agent.id;
                    return next(null, storm);
                  default:
                    return next(new Error("received " + res.statusCode + " from stormtracker"));
                }
              } catch (error) {
                _this.log("unable to lookup agent ID: " + error);
                return next(error);
              }
            });
          }, function(storm, next) {
            var pem, _ref;
            if ((_ref = storm.bolt) == null) {
              storm.bolt = {};
            }
            if ((storm.bolt.cert != null) || ((storm.csr != null) && (storm.bolt.key != null))) {
              return next(null, storm);
            }
            _this.log("generating CSR...");
            try {
              pem = require('pem');
              return pem.createCSR({
                country: "US",
                state: "CA",
                locality: "El Segundo",
                organization: "ClearPath Networks",
                organizationUnit: "CPN",
                commonName: storm.id,
                emailAddress: "" + storm.id + "@intercloud.net"
              }, function(err, res) {
                if ((res != null) && (res.csr != null)) {
                  _this.log("CSR generation completed:", res.csr);
                  storm.csr = res.csr;
                  storm.bolt.key = res.clientKey;
                  if (!(storm.bolt.key instanceof Buffer)) {
                    storm.bolt.key = new Buffer(storm.bolt.key);
                  }
                  return next(null, storm);
                } else {
                  return new Error("CSR generation failure");
                }
              });
            } catch (error) {
              _this.log("unable to generate CSR request");
              return next(error);
            }
          }, function(storm, next) {
            var form, r;
            if ((storm.bolt.cert != null) && (storm.bolt.key != null)) {
              return next(null, storm);
            }
            _this.log("requesting CSR signing from " + storm.tracker + "...");
            r = srequest(request.post, "" + storm.tracker + "/agents/" + storm.id + "/csr", storm, function(err, res, body) {
              var cert;
              try {
                if (err) {
                  next(err);
                }
                switch (res.statusCode) {
                  case 200:
                    try {
                      cert = JSON.parse(body);
                      if ((cert.data != null) && (cert.encoding != null)) {
                        _this.log("decoding signed cert data with " + body.encoding);
                        storm.bolt.cert = new Buffer(cert.data, cert.encoding);
                      } else {
                        _this.log("unkown format for cert... leaving cert AS-IS");
                        storm.bolt.cert = body;
                      }
                    } catch (err) {
                      _this.log("provided cert is not JSON... treating as string");
                      storm.bolt.cert = new Buffer(body);
                    }
                    return next(null, storm);
                  default:
                    return next(new Error("received " + res.statusCode + " from stormtracker"));
                }
              } catch (error) {
                _this.log("unable to post CSR to get signed by stormtracker", error);
                return next(error);
              }
            });
            form = r.form();
            return form.append('file', storm.csr);
          }, function(storm, next) {
            if (storm.bolt.ca != null) {
              return next(null, storm);
            }
            return srequest(request, "" + storm.tracker + "/agents/" + storm.id + "/bolt", storm, function(err, res, body) {
              var bolt;
              try {
                if (err) {
                  next(err);
                }
                switch (res.statusCode) {
                  case 200:
                    bolt = JSON.parse(body);
                    _this.log("retrieving stormbolt configs from stormtracker...", bolt);
                    if (bolt.ca == null) {
                      throw new Error("missing bolt.ca!");
                    }
                    if ((bolt.ca.data != null) && (bolt.ca.encoding != null)) {
                      _this.log("decoding signed cert data with " + bolt.ca.encoding);
                      bolt.ca = new Buffer(bolt.ca.data, bolt.ca.encoding);
                    }
                    storm.bolt = extend(storm.bolt, bolt);
                    return next(null, storm);
                  default:
                    return next(new Error("received " + res.statusCode + " from stormtracker"));
                }
              } catch (error) {
                _this.log("unable to retrieve stormbolt configs");
                return next(error);
              }
            });
          }
        ], function(err, storm) {
          if (err || !storm) {
            _this.log("error during activation:", err);
            return setTimeout(repeat, _this.config.repeatdelay);
          } else {
            _this.log("activation completed successfully");
            _this.state.activated = true;
            _this.emit("activated", storm);
            return repeat(storm);
          }
        });
      }, function(storm) {
        _this.log("final call on until...", storm);
        if (!(storm instanceof Error)) {
          if (callback != null) {
            return callback(storm);
          }
        }
      });
    };

    return StormAgent;

  })(EventEmitter);

  module.exports = StormAgent;

  module.exports.StormData = StormData;

  module.exports.StormRegistry = StormRegistry;

  if (require.main === module) {
    argv = require('minimist')(process.argv.slice(2));
    if (argv.h != null) {
      console.log("-h view this help\n-p port number\n-l logfile\n-d datadir");
      return;
    }
    config = {};
    config.port = (_ref = argv.p) != null ? _ref : 5000;
    config.logfile = (_ref1 = argv.l) != null ? _ref1 : "/var/log/stormagent.log";
    config.datadir = (_ref2 = argv.d) != null ? _ref2 : "/var/stormstack";
    storm = null;
    agent = new StormAgent(config);
    agent.on("running", function() {
      var _this = this;
      this.log("unit testing...");
      this.log("#1 - agent.env.discover", this.env.discover());
      this.log("#2 - agent.env.os", this.env.os());
      this.log("#3 - agent.activate");
      return this.activate(storm, function(err, status) {
        return _this.log("activation completed with", status);
      });
    });
    agent.on("activated", function(storm) {
      return this.log("activated with:", storm);
    });
    agent.run();
    if (typeof gc !== "undefined" && gc !== null) {
      setInterval((function() {
        return gc();
      }), 60000);
    }
  }

}).call(this);
