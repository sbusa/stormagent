// Generated by CoffeeScript 1.7.1
(function() {
  var EventEmitter, StormAgent,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  EventEmitter = require('events').EventEmitter;

  StormAgent = (function(_super) {
    var async, extend, fs, path, validate;

    __extends(StormAgent, _super);

    validate = require('json-schema').validate;

    fs = require('fs');

    path = require('path');

    extend = require('util')._extend;

    async = require('async');

    function StormAgent(config) {
      var util, uuid;
      util = require('util');
      this.log = function(message, obj) {
        var out;
        if (message != null) {
          out = "" + this.constructor.name + ": " + message;
        }
        if (obj != null) {
          out += "\n" + util.inspect(obj);
        }
        if (out != null) {
          return util.log(out);
        }
      };
      this.newdb = function(filename, callback) {
        var dirty;
        if (filename != null) {
          dirty = require('dirty')("" + filename);
        }
        dirty._writeStream.on('error', (function(_this) {
          return function(err) {
            _this.log(err);
            if (callback != null) {
              return callback(err);
            }
          };
        })(this));
        return dirty._writeStream.on('open', (function(_this) {
          return function() {
            _this.log('dirty db initialized ok');
            if (callback != null) {
              return callback(null, dirty);
            }
          };
        })(this));
      };
      this.timestamp = function() {
        var d, months, pad, time;
        d = new Date();
        pad = function(n) {
          var sn;
          sn = n.toString(10);
          if (n < 10) {
            sn = '0' + sn;
          }
          return sn;
        };
        time = [pad(d.getHours()), pad(d.getMinutes()), pad(d.getSeconds())].join(':');
        months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
        return [d.getDate(), months[d.getMonth()], time].join(' ');
      };
      uuid = require('node-uuid');
      this.state = {
        id: null,
        instance: uuid.v4(),
        activated: false,
        running: false,
        env: null
      };
      if (this.config == null) {
        this.config = {};
      }
      if (this.functions == null) {
        this.functions = [];
      }
      this["import"](module);
      if (config != null) {
        this.config = extend(this.config, config);
      }
      this.log("agent.config", this.config);
      this.log("agent.functions", this.functions);
      this.env = require('./environment');

      /*
      @log "setting up directories..."
      fs=require('fs')
      try
          fs.mkdirSync("#{config.datadir}") unless fs.existsSync("#{config.datadir}")
          fs.mkdirSync("#{config.datadir}/db")  unless fs.existsSync("#{config.datadir}/db")
          fs.mkdirSync("#{config.datadir}/certs") unless fs.existsSync("#{config.datadir}/certs")
      catch error
          util.log "Error in creating data dirs"
       */
      this.on('running', (function(_this) {
        return function(include) {
          _this.include = include;
          return _this.state.running = true;
        };
      })(this));
    }

    StormAgent.prototype.status = function() {
      this.state.config = this.config;
      this.state.os = this.env.os();
      return this.state;
    };

    StormAgent.prototype.run = function() {
      var _agent, _ref;
      _agent = this;
      return _ref = require('zappajs')(this.config.port, function() {
        var logger, morgan;
        morgan = require('morgan');
        morgan.token('date', _agent.timestamp);
        morgan.token('response', function(req, res) {
          return res.on("data", function(chunk) {
            return _agent.log("response:", chunk);
          });
        });
        logger = morgan(":date - :remote-addr :method :url :status :response-time ms :response");
        this.configure((function(_this) {
          return function() {
            _this.use('bodyParser', 'methodOverride', logger, require("passport").initialize(), _this.app.router, 'static');
            _this.set({
              'basepath': '/v1.0'
            });
            return _this.set({
              'agent': _agent
            });
          };
        })(this));
        this.configure({
          development: (function(_this) {
            return function() {
              return _this.use({
                errorHandler: {
                  dumpExceptions: true,
                  showStack: true
                }
              });
            };
          })(this),
          production: (function(_this) {
            return function() {
              return _this.use('errorHandler');
            };
          })(this)
        });
        this.enable('serve jquery', 'minify');
        return _agent.emit('running', this.include);
      }), this.app = _ref.app, _ref;
    };

    StormAgent.prototype["import"] = function(id) {
      var err, p, pkgconfig, plugfile, plugin, self, storm, _i, _len, _ref, _ref1;
      if (id instanceof Object && (id.filename != null)) {
        self = true;
        id = p = id.filename;
        while ((p = path.dirname(p)) && p !== path.sep && !fs.existsSync("" + p + "/package.json")) {
          this.log("checking " + p + "...");
        }
        if (p !== path.sep) {
          id = p;
        }
      }
      try {
        pkgconfig = require("" + id + "/package.json").config;
        storm = pkgconfig.storm;
        this.log("import - [" + id + "] processing storm compatible module...");
        if (storm.functions != null) {
          this.log("import - [" + id + "] extending config and functions...");
          if (!this.state.running) {
            this.config = extend(this.config, pkgconfig);
          }
          delete this.config.storm;
          this.log("import - [" + id + "] available functions:", storm.functions);
          if (storm.functions != null) {
            (_ref = this.functions).push.apply(_ref, storm.functions);
          }
        }
        if (storm.plugins != null) {
          this.log("import - [" + id + "] available plugins:", storm.plugins);
          _ref1 = storm.plugins;
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            plugfile = _ref1[_i];
            plugin = require("" + id + "/" + plugfile);
            if (!plugin) {
              continue;
            }
            this.log("import - [" + id + "] found valid plugin at " + plugfile);
            if (this.state.running) {
              this.include(plugin);
            }
            this.on('running', (function(_this) {
              return function(include) {
                _this.include = include;
                _this.log("loading storm-compatible plugin for: " + id + "/" + plugfile);
                return _this.include(plugin);
              };
            })(this));
          }
        }
      } catch (_error) {
        err = _error;
        this.log(("import - [" + id + "] is not a storm compatible module: ") + err);
      }
      try {
        if (!((self != null) && self)) {
          return require("" + id);
        }
      } catch (_error) {
        err = _error;
        return this.log(("import - [" + id + "] failed with: ") + err);
      }
    };

    StormAgent.prototype.execute = function(command, callback) {
      var exec;
      if (!command) {
        return callback(new Error("no valid command for execution!"));
      }
      console.log("executing " + command + "...");
      exec = require('child_process').exec;
      return exec(command, (function(_this) {
        return function(error, stdout, stderr) {
          if (error) {
            return callback(error);
          } else {
            return callback();
          }
        };
      })(this));
    };

    StormAgent.prototype.activate = function(storm, callback) {
      var count, request, srequest;
      request = require('request');
      count = 0;
      srequest = function(method, url, storm, callback) {
        if ((method != null) && method instanceof Function && (url != null) && (storm != null)) {
          return method(url, function(err, res, body) {
            if (callback != null) {
              return callback(err, res, body);
            }
          }).auth(storm.skey, storm.token);
        }
      };
      return async.until((function(_this) {
        return function() {
          return (_this.state.activated != null) && _this.state.activated;
        };
      })(this), (function(_this) {
        return function(repeat) {
          count++;
          _this.log("attempting activation (try " + count + ")...");
          return async.waterfall([
            function(next) {
              if ((storm != null) && (storm.tracker != null) && (storm.skey != null) && (storm.token != null)) {
                return next(null, storm);
              }
              _this.log("discovering environment...");
              return _this.env.discover(function(storm) {
                if ((storm != null) && (storm.provider != null) && (storm.skey != null)) {
                  _this.log("detected provider as: " + storm.provider + " with skey: " + storm.skey);
                  if ((storm.tracker != null) && (storm.token != null)) {
                    _this.state.env = storm;
                    return next(null, storm);
                  } else {
                    return next(new Error("unable to retrieve storm tracker and token data!"));
                  }
                } else {
                  return next(new Error("unable to discover environment!"));
                }
              });
            }, function(storm, next) {
              if (storm.id != null) {
                _this.state.id = storm.id;
                return next(null, storm);
              }
              _this.log("looking up agent ID from stormtracker... " + storm.tracker);
              return srequest(request, "" + storm.tracker + "/skey/" + storm.skey, storm, function(err, res, body) {
                var agent, error;
                try {
                  if (err) {
                    next(err);
                  }
                  switch (res.statusCode) {
                    case 200:
                      agent = JSON.parse(body);
                      _this.state.id = storm.id = agent.id;
                      return next(null, storm);
                    default:
                      return next(err);
                  }
                } catch (_error) {
                  error = _error;
                  _this.log("unable to lookup agent ID: " + error);
                  return next(error);
                }
              });
            }, function(storm, next) {
              var error, pem;
              if (storm.bolt == null) {
                storm.bolt = {};
              }
              if ((storm.bolt.cert != null) || ((storm.csr != null) && (storm.bolt.key != null))) {
                return next(null, storm);
              }
              _this.log("generating CSR...");
              try {
                pem = require('pem');
                return pem.createCSR({
                  country: "US",
                  state: "CA",
                  locality: "El Segundo",
                  organization: "ClearPath Networks",
                  organizationUnit: "CPN",
                  commonName: storm.id,
                  emailAddress: "" + storm.id + "@intercloud.net"
                }, function(err, res) {
                  if ((res != null) && (res.csr != null)) {
                    _this.log("CSR generation completed:", res.csr);
                    storm.csr = res.csr;
                    storm.bolt.key = res.clientKey;
                    return next(null, storm);
                  } else {
                    return new Error("CSR generation failure");
                  }
                });
              } catch (_error) {
                error = _error;
                _this.log("unable to generate CSR request");
                return next(error);
              }
            }, function(storm, next) {
              var form, r;
              if ((storm.bolt.cert != null) && (storm.bolt.key != null)) {
                return next(null, storm);
              }
              _this.log("requesting CSR signing from " + storm.tracker + "...");
              r = srequest(request.post, "" + storm.tracker + "/" + storm.id + "/csr", storm, function(err, res, body) {
                var error;
                try {
                  switch (res.statusCode) {
                    case 200:
                      storm.bolt.cert = body;
                      return next(null, storm);
                    default:
                      return next(err);
                  }
                } catch (_error) {
                  error = _error;
                  _this.log("unable to post CSR to get signed by stormtracker");
                  return next(error);
                }
              });
              form = r.form();
              return form.append('file', storm.csr);
            }, function(storm, next) {
              if (storm.bolt.ca != null) {
                return next(null, storm);
              }
              _this.log("retrieving stormbolt configs from stormtracker...");
              return srequest(request, "" + storm.tracker + "/" + storm.id + "/bolt", storm, function(err, res, body) {
                var bolt, error;
                try {
                  switch (res.statusCode) {
                    case 200:
                      bolt = JSON.parse(body);
                      storm.bolt = extend(storm.bolt, bolt);
                      return next(null, storm);
                    default:
                      return next(err);
                  }
                } catch (_error) {
                  error = _error;
                  _this.log("unable to retrieve stormbolt configs");
                  return next(error);
                }
              });
            }
          ], function(err, storm) {
            if (storm != null) {
              _this.log("activation completed successfully");
              _this.state.activated = true;
              _this.emit("activated", storm);
              return repeat(null, storm);
            } else {
              _this.log("error during activation: " + err);
              return setTimeout(repeat, _this.config.repeatdelay);
            }
          });
        };
      })(this), (function(_this) {
        return function(err, storm) {
          _this.log("final call on until...");
          if (callback != null) {
            return callback(err, storm);
          }
        };
      })(this));
    };

    return StormAgent;

  })(EventEmitter);

  module.exports = StormAgent;

  if (typeof gc !== "undefined" && gc !== null) {
    setInterval((function() {
      return gc();
    }), 2000);
  }

}).call(this);
